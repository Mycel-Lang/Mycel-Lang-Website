# Error E5001: Stack overflow

## Summary

This error occurs when a function calls itself recursively without a proper exit condition, leading to an infinite chain of calls that exhausts the available stack memory.

---

## The Problem

Every time a function is called, a small amount of memory, called a "stack frame," is used to store its local variables and the return address. When a function calls itself recursively, a new stack frame is added for each call. If this recursion never stops, the stack will grow infinitely until it runs out of its allocated space.

```mycel
// This function calls itself forever, with no way to stop.
fn infiniteLoop() {
  // This will eventually cause a stack overflow.
  @infiniteLoop();
}

@infiniteLoop()
```

## The Solution

Rewrite the recursive function to include a **base case**. A base case is a condition that stops the recursion, allowing the chain of calls to unwind.

```mycel
fn countDown(n: number) {
  // The base case: if n is 0 or less, stop the recursion.
  if (n <= 0) {
    return;
  }

  @print(n);

  // The recursive step: call the function with a smaller number.
  @countDown(n - 1);
}

// This will now correctly count down from 5 to 1 and then stop.
@countDown(5)
```

---

## Detailed Explanation

The "call stack" is a fundamental concept in most programming languages. It's a LIFO (Last-In, First-Out) data structure that keeps track of the currently executing functions. When `a()` calls `b()`, `b` is pushed onto the stack. When `b()` finishes, it is popped off, and control returns to `a()`.

A stack overflow is a specific kind of out-of-memory error. While `E5000` (OOM) refers to running out of general-purpose (heap) memory, a stack overflow means running out of the special, limited memory allocated for the call stack.

In Mycel, this error is almost exclusively caused by infinite recursion in a function. The function keeps calling itself, pushing a new frame onto the stack each time, until the stack's memory limit is hit. The compiler or runtime environment then terminates the process to prevent further damage.

To fix a stack overflow, you must analyze your recursive function and ensure it has a valid base case:

1.  **Identify the Base Case:** What is the simplest possible input for this function where the answer is known without further recursion? (e.g., for a factorial function, the base case is `n=0`).
2.  **Ensure it is Reachable:** Does the recursive step modify the input in a way that it will eventually reach the base case? (e.g., calling `factorial(n-1)` gets closer to `n=0`).

By ensuring your recursion always has a guaranteed exit, you can prevent stack overflows.
