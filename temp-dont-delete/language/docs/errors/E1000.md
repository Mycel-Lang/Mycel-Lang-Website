# Error E1000: Mismatched types in function call

## Summary

This error occurs when you call a function with an argument that has a different type than what the function definition expects.

---

## The Problem

When you define a function with type annotations, you are creating a contract. The function promises to only accept arguments of the specified types. If you then call that function with an argument of a different type, you are breaking that contract.

```mycel
fn calculatePrice(price: number, tax: number) -> number {
  return price * (1 + tax);
}

// Calling the function with a string ("100") instead of a number.
let finalPrice = @calculatePrice("100", 0.05);
```

## The Solution

Ensure that the arguments you pass to a function match the types specified in its definition.

```mycel
fn calculatePrice(price: number, tax: number) -> number {
  return price * (1 + tax);
}

// Call the function with a number (100) as expected.
let finalPrice = @calculatePrice(100, 0.05);
```

---

## Detailed Explanation

Mycel's optional type system is designed to help you catch errors early and write more robust code. When you declare `fn calculatePrice(price: number, ...)` you are telling the compiler that the `price` parameter *must* be a number.

This allows the compiler to make guarantees about how the function will behave. It knows that it is safe to perform mathematical operations on the `price` variable.

If the compiler were to allow you to pass a string like `"100"`, it would lead to a runtime error inside the function when it tries to multiply a string by a number. Instead of letting this happen, the compiler stops and reports error `E1000` at the source of the problem: the function call.

When you encounter this error, check two things:

1.  The value you are passing to the function. Is it the correct type?
2.  The function's definition. Are the type annotations correct for what you are trying to achieve?
